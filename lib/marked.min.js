/* Tiny Markdown parser (ESM) â€” headings, lists, paragraphs, **bold**, *italic*, `code`, ```fences```, links [t](u) */
function escHtml(s) {
	return String(s)
		.replace(/&/g, "&amp;").replace(/</g, "&lt;")
		.replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

function inline(md) {
	// code
	md = md.replace(/`([^`]+)`/g, (_, c) => `<code>${escHtml(c)}</code>`);
	// bold/italic (order matters)
	md = md.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
	md = md.replace(/\*([^*]+)\*/g, "<em>$1</em>");
	// links
	md = md.replace(/$begin:math:display$([^$end:math:display$]+)\]$begin:math:text$([^)]+)$end:math:text$/g, (_, t, u) => {
		const safe = u.trim().startsWith("javascript:") ? "#" : u;
		return `<a href="${escHtml(safe)}">${escHtml(t)}</a>`;
	});
	return md;
}

function parse(md) {
	if (!md) return "";
	const lines = String(md).replace(/\r\n?/g, "\n").split("\n");

	// Handle fenced code blocks first
	let i = 0,
		out = [];
	while (i < lines.length) {
		const line = lines[i];
		const fence = line.match(/^```(\w+)?\s*$/);
		if (fence) {
			const lang = fence[1] || "";
			let buf = [],
				j = i + 1;
			while (j < lines.length && !/^```/.test(lines[j])) { buf.push(lines[j]);
				j++; }
			out.push(`<pre><code class="language-${lang}">${escHtml(buf.join("\n"))}</code></pre>`);
			i = (j < lines.length ? j + 1 : j);
			continue;
		}
		// Headings
		const h = line.match(/^(#{1,6})\s+(.*)$/);
		if (h) { out.push(`<h${h[1].length}>${inline(escHtml(h[2]))}</h${h[1].length}>`);
			i++; continue; }

		// Lists (simple)
		if (/^(\s*)[-*+]\s+/.test(line)) {
			let items = [],
				j = i;
			while (j < lines.length && /^(\s*)[-*+]\s+/.test(lines[j])) {
				items.push(lines[j].replace(/^(\s*)[-*+]\s+/, ""));
				j++;
			}
			out.push("<ul>" + items.map(it => `<li>${inline(escHtml(it))}</li>`).join("") + "</ul>");
			i = j;
			continue;
		}
		if (/^(\s*)\d+\.\s+/.test(line)) {
			let items = [],
				j = i;
			while (j < lines.length && /^(\s*)\d+\.\s+/.test(lines[j])) {
				items.push(lines[j].replace(/^(\s*)\d+\.\s+/, ""));
				j++;
			}
			out.push("<ol>" + items.map(it => `<li>${inline(escHtml(it))}</li>`).join("") + "</ol>");
			i = j;
			continue;
		}

		// Blank => paragraph break
		if (/^\s*$/.test(line)) { out.push("");
			i++; continue; }

		// Paragraph (consume consecutive non-blank, non-list, non-heading lines)
		let para = [line],
			j = i + 1;
		while (j < lines.length &&
			!/^\s*$/.test(lines[j]) &&
			!/^(\s*)[-*+]\s+/.test(lines[j]) &&
			!/^(\s*)\d+\.\s+/.test(lines[j]) &&
			!/^(#{1,6})\s+/.test(lines[j]) &&
			!/^```/.test(lines[j])) {
			para.push(lines[j]);
			j++;
		}
		out.push(`<p>${inline(escHtml(para.join(" ").replace(/\s+/g," ").trim()))}</p>`);
		i = j;
	}
	return out.filter(Boolean).join("\n");
}

export const marked = {
	parse(md, _opts = {}) { return parse(md); }
};
export default marked;
