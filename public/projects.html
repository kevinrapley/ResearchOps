<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Projects — ResearchOps Demo Suite</title>

	<link rel="stylesheet" href="./css/govuk/govuk-typography.css" media="screen" />
	<link rel="stylesheet" href="./css/govuk/govuk-colours.css" media="screen" />
	<link rel="stylesheet" href="./css/screen.css" media="screen" />
	<script type="module" src="./components/layout.js"></script>
</head>

<body>
	<!-- Global header -->
	<x-include src="./partials/header.html" vars='{
			"active":"Projects",
			"subtitle":"Browse projects created in this demo suite"
		}'>
	</x-include>

	<main class="govuk-body" role="main">
		<h1 class="govuk-heading-l" style="margin-top:0">Projects</h1>
		<div id="list"></div>
	</main>

	<x-include src="./partials/footer.html" vars='{"org":"Home Office Biometrics","build":"ResearchOps v1.0.0 (demo)"}'>
	</x-include>

	<script type="module">
		/**
		 * @file projects-ui.js (inline)
		 * @module ProjectsUI
		 * @description
		 * Projects list UI with Airtable-first read and CSV fallback.
		 * Adds createdAt mapping and sorts newest-first. Class-based client,
		 * lifecycle (reset/destroy), timeout/abort, batched logging, and JSDoc.
		 */

		/* =========================
		 * @section Configuration
		 * ========================= */
		const CONFIG = Object.freeze({
			API_BASE: "", // empty = same origin (recommended)
			FETCH_TIMEOUT_MS: 12_000,
			LOG_BATCH_INTERVAL_MS: 500,
			CACHE: "no-store",
			SHOW_SOURCE_NOTE: false
		});

		/* =========================
		 * @section Utilities
		 * ========================= */
		const apiBase = CONFIG.API_BASE || `${location.origin}`;

		/** Parse a date safely to ms (NaN -> 0). */
		function toMs(d) {
			const n = Date.parse(d);
			return Number.isFinite(n) ? n : 0;
		}

		/**
		* @class Emitter
 		* @classdesc Lightweight emitter.
 		*/
		class Emitter {
			/** @type {Record<string, Array<{fn:Function}>>} */
			#m = Object.create(null);
			on(evt, fn) {
				(this.#m[evt] ||= []).push({ fn }); return () => this.off(evt, fn); }
			off(evt, fn) { const a = this.#m[evt]; if (!a) return; const i = a.findIndex(l => l.fn === fn); if (i >= 0) a.splice(i, 1); }
			emit(evt, payload) {
				(this.#m[evt] || []).forEach(l => l.fn(payload)); }
			reset() { this.#m = Object.create(null); }
		}

		/**
		* @class BatchedLogger
 		* @classdesc Batched console logger.
 		*/
		class BatchedLogger {
			#q = [];
			#timer = null;
			#interval = CONFIG.LOG_BATCH_INTERVAL_MS;
			log(level, msg, meta) {
				this.#q.push({ t: new Date().toISOString(), level, msg, meta });
				if (!this.#timer) this.#timer = setTimeout(() => this.#flush(), this.#interval);
			}
			#flush() {
				const batch = this.#q.splice(0);
				this.#timer = null;
				if (!batch.length) return;
				console.groupCollapsed(`[ProjectsUI] ${batch.length} event(s)`);
				for (const e of batch) {
					const line = `${e.t} [${e.level}] ${e.msg}`;
					if (e.level === "error") console.error(line, e.meta ?? "");
					else if (e.level === "warn") console.warn(line, e.meta ?? "");
					else console.log(line, e.meta ?? "");
				}
				console.groupEnd();
			}
			reset() { clearTimeout(this.#timer);
				this.#timer = null;
				this.#q.length = 0; }
			destroy() { this.reset(); }
		}

		/* =========================
		 * @section CSV helpers
		 * ========================= */
		 
		/**
		* @function parseCSV
 		*/
		function parseCSV(text) {
			const rows = [];
			let row = [],
				field = "",
				inQuotes = false;
			for (let i = 0; i < text.length; i++) {
				const c = text[i],
					n = text[i + 1];
				if (inQuotes) {
					if (c === '"' && n === '"') { field += '"';
						i++; } else if (c === '"') { inQuotes = false; } else { field += c; }
				} else {
					if (c === '"') inQuotes = true;
					else if (c === ',') { row.push(field);
						field = ""; } else if (c === '\r') { /* ignore */ } else if (c === '\n') { row.push(field);
						rows.push(row);
						row = [];
						field = ""; } else { field += c; }
				}
			}
			if (field.length || row.length) { row.push(field);
				rows.push(row); }
			return rows;
		}

		/**
		* @function safeJsonArray
 		*/
		function safeJsonArray(s) {
			try { const v = JSON.parse(String(s)); return Array.isArray(v) ? v : []; } catch { return []; }
		}

		/**
		* @function mapProjectRow
		* @description Map CSV row -> UI model (adds createdAt)
 		*/
		function mapProjectRow(header, row) {
			const idx = (name) => header.indexOf(name);
			const get = (name) => { const i = idx(name); return i >= 0 ? (row[i] ?? "") : ""; };

			const name = get("Name");
			const description = get("Description");
			const phase = get("Phase") || "Discovery";
			const status = get("Status") || "Planning research";
			const objectives = (get("Objectives") || "").split("|").map(s => s.trim()).filter(Boolean);
			const user_groups = (get("UserGroups") || "").split("|").map(s => s.trim()).filter(Boolean);
			let stakeholders = [];
			try { stakeholders = JSON.parse(get("Stakeholders") || "[]"); } catch { stakeholders = []; }

			return {
				id: get("LocalId") || undefined,
				name,
				description,
				stakeholders,
				objectives,
				user_groups,
				createdAt: get("CreatedAt") || "", // <- used for sorting
				['rops:servicePhase']: phase,
				['rops:projectStatus']: status
			};
		}

		/* =========================
		 * @section Projects Data Client
		 * ========================= */
		/**
		 * @typedef {Object} UIProject
		 * @property {string=} id
		 * @property {string} name
		 * @property {string} description
		 * @property {Array<{name:string,role?:string,email?:string}>} stakeholders
		 * @property {string[]} objectives
		 * @property {string[]} user_groups
		 * @property {string} createdAt
		 * @property {string} ['rops:servicePhase']
		 * @property {string} ['rops:projectStatus']
		 */

		/**
		* @class ProjectsDataClient
 		* @classdesc 
 		*/
		class ProjectsDataClient {
			#apiBase;
			#emitter = new Emitter();
			#logger = new BatchedLogger();
			#aborts = new Set();
			/** @type {{source:'airtable'|'csv'|null, projects:UIProject[]}} */
			state = { source: null, projects: [] };

			constructor(apiBaseIn = apiBase) { this.#apiBase = apiBaseIn; }
			reset() { for (const c of this.#aborts) c.abort();
				this.#aborts.clear();
				this.state = { source: null, projects: [] };
				this.#logger.reset();
				this.#emitter.emit("reset"); }
			destroy() { this.reset();
				this.#emitter.reset();
				this.#logger.destroy(); }
			on(evt, fn) { return this.#emitter.on(evt, fn); }

			async #fetchJson(url) {
				const ctl = new AbortController();
				this.#aborts.add(ctl);
				const timer = setTimeout(() => ctl.abort("timeout"), CONFIG.FETCH_TIMEOUT_MS);
				try {
					const res = await fetch(url, { signal: ctl.signal, credentials: "omit", cache: CONFIG.CACHE });
					const text = await res.text();
					let data;
					try { data = JSON.parse(text); } catch { data = { ok: false, parseError: true, raw: text }; }
					return { ok: res.ok, status: res.status, data };
				} finally { clearTimeout(timer);
					this.#aborts.delete(ctl); }
			}

			/** Primary: Airtable via Worker /api/projects (maps createdAt) */
			async listFromAirtable() {
				const url = `${this.#apiBase}/api/projects`;
				this.#logger.log("info", "GET /api/projects (airtable)");
				const { ok, status, data } = await this.#fetchJson(url);
				if (!ok || !data?.ok) {
					const m = `Airtable list failed (${status})`;
					this.#logger.log("warn", m, { status, data });
					throw new Error(m);
				}
				const projects = (data.projects || []).map((p) => ({
					id: p.LocalId || p.id,
					name: p.Name,
					description: p.Description,
					stakeholders: Array.isArray(p.Stakeholders) ? p.Stakeholders : p.Stakeholders ? safeJsonArray(p.Stakeholders) : [],
					objectives: Array.isArray(p.Objectives) ? p.Objectives : p.Objectives ? String(p.Objectives).split("\n").map(s => s.trim()).filter(Boolean) : [],
					user_groups: Array.isArray(p.UserGroups) ? p.UserGroups : p.UserGroups ? String(p.UserGroups).split(",").map(s => s.trim()).filter(Boolean) : [],
					createdAt: p.createdAt || p.CreatedAt || "", // <- Worker now returns this; keep fallbacks
					['rops:servicePhase']: p.Phase,
					['rops:projectStatus']: p.Status
				}));
				this.state = { source: "airtable", projects };
				this.#emitter.emit("update", this.state);
				return projects;
			}

			/** Fallback: CSV via /api/projects.csv (maps CreatedAt column) */
			async listFromCsv() {
				const ctl = new AbortController();
				this.#aborts.add(ctl);
				const timer = setTimeout(() => ctl.abort("timeout"), CONFIG.FETCH_TIMEOUT_MS);
				try {
					const res = await fetch(`${this.#apiBase}/api/projects.csv`, { cache: CONFIG.CACHE, signal: ctl.signal });
					if (!res.ok) throw new Error(`CSV fetch failed (${res.status})`);
					const text = await res.text();
					const rows = parseCSV(text);
					if (!rows.length) {
						this.state = { source: "csv", projects: [] };
						this.#emitter.emit("update", this.state);
						return [];
					}
					const [headerRow, ...dataRows] = rows;
					const header = headerRow.map(h => (h || "").trim());
					const projects = dataRows
						.filter(r => r && r.some(cell => (cell || "").trim().length))
						.map(r => mapProjectRow(header, r));
					this.state = { source: "csv", projects };
					this.#emitter.emit("update", this.state);
					return projects;
				} finally { clearTimeout(timer);
					this.#aborts.delete(ctl); }
			}

			/** Prefer Airtable; fallback to CSV */
			async listProjects() {
				try { return await this.listFromAirtable(); } catch (e) { this.#logger.log("warn", "Falling back to CSV", { error: String(e?.message || e) }); return await this.listFromCsv(); }
			}
		}

		/* =========================
		 * @section UI bootstrap
		 * ========================= */
		const container = document.getElementById("list");
		const client = new ProjectsDataClient(apiBase);

		function card(p) {
			const groups = (p.user_groups || []).map(g => `<span class="tag">${g}</span>`).join(" ");
			return `<article class="card">
    <h2 class="govuk-heading-m" style="margin:0">${p.name}</h2>
    <div class="lede">Phase: ${p['rops:servicePhase']} · Status: ${p['rops:projectStatus']}</div>
    ${p.description ? `<p>${p.description}</p>` : ""}
    ${groups ? `<div>${groups}</div>` : ""}
    <details style="margin-top:8px">
      <summary class="govuk-link">Stakeholders & Objectives</summary>
      <div><strong>Stakeholders</strong></div>
      <ul>
        ${(p.stakeholders || []).map(s => `<li>${s.name || ""} ${s.role || ""} ${s.email || ""}</li>`).join("") || "<li class='lede'>None</li>"}
      </ul>
      <div><strong>Objectives</strong></div>
      <ul>
        ${(p.objectives || []).map(o => `<li>${o}</li>`).join("") || "<li class='lede'>None</li>"}
      </ul>
    </details>
  </article>`;
		}

		function render(projects, source) {
			// NEW: newest-first by createdAt (Airtable CreatedAt or record.createdTime; CSV CreatedAt column)
			projects.sort((a, b) => toMs(b.createdAt) - toMs(a.createdAt));

			if (!projects.length) {
				container.innerHTML = '<p class="lede">No projects yet. <a class="govuk-link" href="./start.html">Create one</a>.</p>';
				return;
			}
			container.innerHTML = projects.map(card).join("");
			if (CONFIG.SHOW_SOURCE_NOTE) {
				const srcNote = document.createElement("p");
				srcNote.className = "lede";
				srcNote.textContent = `Source: ${source}`;
				container.prepend(srcNote);
			}
		}

		(async () => {
			try {
				const projects = await client.listProjects();
				render(projects, client.state.source);
			} catch (e) {
				container.innerHTML = `<p class="lede">Could not load projects (${e?.message || e}).</p>`;
			}
		})();

		/* =========================
		 * @section Test / Mock exports
		 * ========================= */
		window.__rops = Object.freeze({
			CONFIG,
			ProjectsDataClient,
			parseCSV,
			toMs,
			reset: () => client.reset(),
			destroy: () => client.destroy()
		});
	</script>
</body>

</html>
