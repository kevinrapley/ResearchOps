<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="sda-auto" content="true" />
	<title>Projects â€” ResearchOps Demo Suite</title>

	<link rel="stylesheet" href="/css/govuk/govuk-typography.css" media="screen" />
	<link rel="stylesheet" href="/css/govuk/govuk-colours.css" media="screen" />
	<link rel="stylesheet" href="/css/screen.css" media="screen" />

	<!-- Components/layout first -->
	<script type="module" src="/components/layout.js" defer></script>
</head>

<body>
	<x-include src="/partials/debug.html"></x-include>
	<!-- Global header -->
	<x-include src="/partials/header.html" vars='{
			"active":"Projects",
			"subtitle":"Browse projects created in this demo suite"
		}'>
	</x-include>

	<main class="govuk-body" role="main">
		<h1 class="govuk-heading-l" style="margin-top:0">Projects</h1>
		<div id="list"></div>
	</main>

	<x-include src="/partials/footer.html" vars='{"org":"Home Office Biometrics","build":"ResearchOps v1.0.0 (demo)"}'>
	</x-include>

	<script type="module">
		/**
		 * @file projects-ui.js (inline)
		 * @module ProjectsUI
		 * @description
		 * Projects list UI with Airtable-first read and CSV fallback.
		 * Adds createdAt mapping and sorts newest-first. Class-based client,
		 * lifecycle (reset/destroy), timeout/abort, batched logging, and JSDoc.
		 */

		/* =========================
		 * @section Configuration
		 * ========================= */
		const CONFIG = Object.freeze({
			API_BASE: "", // empty = same origin (recommended)
			FETCH_TIMEOUT_MS: 12_000,
			LOG_BATCH_INTERVAL_MS: 500,
			CACHE: "no-store",
			SHOW_SOURCE_NOTE: false
		});

		/* =========================
		 * @section Utilities
		 * ========================= */
		const apiBase = CONFIG.API_BASE || `${location.origin}`;

		/** Parse a date safely to ms (NaN -> 0). */
		function toMs(d) {
			const n = Date.parse(d);
			return Number.isFinite(n) ? n : 0;
		}

		/**
		 * @class Emitter
		 * @classdesc Lightweight emitter.
		 */
		class Emitter {
			/** @type {Record<string, Array<{fn:Function}>>} */
			#m = Object.create(null);
			on(evt, fn) {
				(this.#m[evt] ||= []).push({ fn });
				return () => this.off(evt, fn);
			}
			off(evt, fn) { const a = this.#m[evt]; if (!a) return; const i = a.findIndex(l => l.fn === fn); if (i >= 0) a.splice(i, 1); }
			emit(evt, payload) {
				(this.#m[evt] || []).forEach(l => l.fn(payload));
			}
			reset() { this.#m = Object.create(null); }
		}

		/**
		 * @class BatchedLogger
		 * @classdesc Batched console logger.
		 */
		class BatchedLogger {
			#q = [];
			#timer = null;
			#interval = CONFIG.LOG_BATCH_INTERVAL_MS;
			log(level, msg, meta) {
				this.#q.push({ t: new Date().toISOString(), level, msg, meta });
				if (!this.#timer) this.#timer = setTimeout(() => this.#flush(), this.#interval);
			}
			#flush() {
				const batch = this.#q.splice(0);
				this.#timer = null;
				if (!batch.length) return;
				console.groupCollapsed(`[ProjectsUI] ${batch.length} event(s)`);
				for (const e of batch) {
					const line = `${e.t} [${e.level}] ${e.msg}`;
					if (e.level === "error") console.error(line, e.meta ?? "");
					else if (e.level === "warn") console.warn(line, e.meta ?? "");
					else console.log(line, e.meta ?? "");
				}
				console.groupEnd();
			}
			reset() {
				clearTimeout(this.#timer);
				this.#timer = null;
				this.#q.length = 0;
			}
			destroy() { this.reset(); }
		}

		/* =========================
		 * @section CSV helpers
		 * ========================= */

		/**
		 * @function parseCSV
		 */
		function parseCSV(text) {
			const rows = [];
			let row = [],
				field = "",
				inQuotes = false;
			for (let i = 0; i < text.length; i++) {
				const c = text[i],
					n = text[i + 1];
				if (inQuotes) {
					if (c === '"' && n === '"') {
						field += '"';
						i++;
					} else if (c === '"') { inQuotes = false; } else { field += c; }
				} else {
					if (c === '"') inQuotes = true;
					else if (c === ',') {
						row.push(field);
						field = "";
					} else if (c === '\r') { /* ignore */ } else if (c === '\n') {
						row.push(field);
						rows.push(row);
						row = [];
						field = "";
					} else { field += c; }
				}
			}
			if (field.length || row.length) {
				row.push(field);
				rows.push(row);
			}
			return rows;
		}

		/**
		 * @function safeJsonArray
		 */
		function safeJsonArray(s) {
			try { const v = JSON.parse(String(s)); return Array.isArray(v) ? v : []; } catch { return []; }
		}

		/**
		 * @function mapProjectRow
		 * @description Map CSV row -> UI model (adds createdAt)
		 */
		function mapProjectRow(header, row) {
			const idx = (name) => header.indexOf(name);
			const get = (name) => { const i = idx(name); return i >= 0 ? (row[i] ?? "") : ""; };

			const name = get("Name");
			const description = get("Description");
			const phase = get("Phase") || "Discovery";
			const status = get("Status") || "Planning research";
			const objectives = (get("Objectives") || "").split("|").map(s => s.trim()).filter(Boolean);
			const user_groups = (get("UserGroups") || "").split("|").map(s => s.trim()).filter(Boolean);
			let stakeholders = [];
			try { stakeholders = JSON.parse(get("Stakeholders") || "[]"); } catch { stakeholders = []; }

			return {
				id: get("LocalId") || undefined,
				name,
				description,
				stakeholders,
				objectives,
				user_groups,
				createdAt: get("CreatedAt") || "", // <- used for sorting
				['rops:servicePhase']: phase,
				['rops:projectStatus']: status
			};
		}

		/* =========================
		 * @section Projects Data Client
		 * ========================= */
		/**
		 * @typedef {Object} UIProject
		 * @property {string=} id
		 * @property {string} name
		 * @property {string} description
		 * @property {Array<{name:string,role?:string,email?:string}>} stakeholders
		 * @property {string[]} objectives
		 * @property {string[]} user_groups
		 * @property {string} createdAt
		 * @property {string} ['rops:servicePhase']
		 * @property {string} ['rops:projectStatus']
		 */

		/**
		 * @class ProjectsDataClient
		 * @classdesc 
		 */
		class ProjectsDataClient {
			#apiBase;
			#emitter = new Emitter();
			#logger = new BatchedLogger();
			#aborts = new Set();
			/** @type {{source:'airtable'|'csv'|null, projects:UIProject[]}} */
			state = { source: null, projects: [] };

			constructor(apiBaseIn = apiBase) { this.#apiBase = apiBaseIn; }
			reset() {
				for (const c of this.#aborts) c.abort();
				this.#aborts.clear();
				this.state = { source: null, projects: [] };
				this.#logger.reset();
				this.#emitter.emit("reset");
			}
			destroy() {
				this.reset();
				this.#emitter.reset();
				this.#logger.destroy();
			}
			on(evt, fn) { return this.#emitter.on(evt, fn); }

			async #fetchJson(url) {
				const ctl = new AbortController();
				this.#aborts.add(ctl);
				const timer = setTimeout(() => ctl.abort("timeout"), CONFIG.FETCH_TIMEOUT_MS);
				try {
					const res = await fetch(url, { signal: ctl.signal, credentials: "omit", cache: CONFIG.CACHE });
					const text = await res.text();
					let data;
					try { data = JSON.parse(text); } catch { data = { ok: false, parseError: true, raw: text }; }
					return { ok: res.ok, status: res.status, data };
				} finally {
					clearTimeout(timer);
					this.#aborts.delete(ctl);
				}
			}

			/** Primary: Airtable via Worker /api/projects (maps createdAt) */
			async listFromAirtable() {
				const url = `${this.#apiBase}/api/projects`;
				this.#logger.log("info", "GET /api/projects (airtable)");
				const { ok, status, data } = await this.#fetchJson(url);
				if (!ok || !data?.ok) {
					const m = `Airtable list failed (${status})`;
					this.#logger.log("warn", m, { status, data });
					throw new Error(m);
				}
				const projects = (data.projects || []).map((p) => {
					// normalise fields from either Airtable-raw or UI-shaped worker
					const name = p.Name ?? p.name ?? "";
					const description = p.Description ?? p.description ?? "";
					const phase = p.Phase ?? p["rops:servicePhase"] ?? "";
					const status = p.Status ?? p["rops:projectStatus"] ?? "";

					const stakeholders = Array.isArray(p.Stakeholders) ? p.Stakeholders :
						Array.isArray(p.stakeholders) ? p.stakeholders :
						p.Stakeholders ? safeJsonArray(p.Stakeholders) :
						p.stakeholders ? safeJsonArray(p.stakeholders) : [];

					const objectivesRaw = p.Objectives ?? p.objectives ?? "";
					const objectives = Array.isArray(objectivesRaw) ?
						objectivesRaw :
						String(objectivesRaw).split("\n").map(s => s.trim()).filter(Boolean);

					const groupsRaw = p.UserGroups ?? p.user_groups ?? "";
					const user_groups = Array.isArray(groupsRaw) ?
						groupsRaw :
						String(groupsRaw).split(",").map(s => s.trim()).filter(Boolean);

					const createdAt = p.CreatedAt ?? p.createdAt ?? p.createdTime ?? "";

					return {
						id: p.LocalId || p.id,
						name,
						description,
						stakeholders,
						objectives,
						user_groups,
						createdAt,
						['rops:servicePhase']: phase,
						['rops:projectStatus']: status
					};
				});
				this.state = { source: "airtable", projects };
				this.#emitter.emit("update", this.state);
				return projects;
			}

			/** Fallback: CSV via /api/projects.csv (maps CreatedAt column) */
			async listFromCsv() {
				const ctl = new AbortController();
				this.#aborts.add(ctl);
				const timer = setTimeout(() => ctl.abort("timeout"), CONFIG.FETCH_TIMEOUT_MS);
				try {
					const res = await fetch(`${this.#apiBase}/api/projects.csv`, { cache: CONFIG.CACHE, signal: ctl.signal });
					if (!res.ok) throw new Error(`CSV fetch failed (${res.status})`);
					const text = await res.text();
					const rows = parseCSV(text);
					if (!rows.length) {
						this.state = { source: "csv", projects: [] };
						this.#emitter.emit("update", this.state);
						return [];
					}
					const [headerRow, ...dataRows] = rows;
					const header = headerRow.map(h => (h || "").trim());
					const projects = dataRows
						.filter(r => r && r.some(cell => (cell || "").trim().length))
						.map(r => mapProjectRow(header, r));
					this.state = { source: "csv", projects };
					this.#emitter.emit("update", this.state);
					return projects;
				} finally {
					clearTimeout(timer);
					this.#aborts.delete(ctl);
				}
			}

			/** Prefer Airtable; fallback to CSV */
			async listProjects() {
				try { return await this.listFromAirtable(); } catch (e) { this.#logger.log("warn", "Falling back to CSV", { error: String(e?.message || e) }); return await this.listFromCsv(); }
			}
		}

		/* =========================
		 * @section UI bootstrap
		 * ========================= */
		const container = document.getElementById("list");
		const client = new ProjectsDataClient(apiBase);

		function card(p) {
			const org = p.org || p.Org || "Home Office Biometrics";
			const projectId = encodeURIComponent(p.id || p.LocalId || "");
			const phase = p["rops:servicePhase"] || "";
			const status = p["rops:projectStatus"] || "";
			const groups = (p.user_groups || []).map(g => `<li><span class="tag">${g}</span></li>`).join("");

			return `
<article class="card" aria-labelledby="project-title-${projectId}">
	<p class="project-org">${org}</p>
	<h2 id="project-title-${projectId}" class="project-title govuk-heading-m">
		<a class="govuk-link" href="/pages/project-dashboard/?id=${projectId}" rel="bookmark">${p.name}</a>
	</h2>

	<p class="project-meta">
		<strong>Phase:</strong> ${phase} Â· <strong>Status:</strong> ${status}
	</p>

	${p.description ? `<section class="project-summary"><p>${p.description}</p></section>` : ""}

	${(p.user_groups && p.user_groups.length) ? `
	<section class="user-groups" aria-labelledby="user-groups-${projectId}">
		<h3 id="user-groups-${projectId}" class="project-groups-title">User Groups</h3>
		<ul class="tags" role="list">
			${groups}
		</ul>
	</section>` : ""}

	<section class="project-extra">
		<details class="project-details">
			<summary class="govuk-link">Stakeholders &amp; Objectives</summary>
			<div class="details-columns">
				<div>
					<h4 class="govuk-heading-s">Stakeholders</h4>
					<ul role="list">
						${(p.stakeholders || []).map(s => {
							const name = s.name || "";
							const role = s.role ? ` â€” ${s.role}` : "";
							const email = s.email ? ` <a href="mailto:${s.email}" class="govuk-link">${s.email}</a>` : "";
							return `<li>${name}${role}${email}</li>`;
						}).join("") || "<li class='lede'>None</li>"}
					</ul>
				</div>
				<div>
					<h4 class="govuk-heading-s">Objectives</h4>
					<ul role="list">
						${(p.objectives || []).map(o => `<li>${o}</li>`).join("") || "<li class='lede'>None</li>"}
					</ul>
				</div>
			</div>
		</details>
	</section>
</article>`;
		}

		function render(projects, source) {
			// NEW: newest-first by createdAt (Airtable CreatedAt or record.createdTime; CSV CreatedAt column)
			projects.sort((a, b) => toMs(b.createdAt) - toMs(a.createdAt));

			if (!projects.length) {
				container.innerHTML = '<p class="lede">No projects yet. <a class="govuk-link" href="./pages/start/">Create one</a>.</p>';
				return;
			}
			container.innerHTML = projects.map(card).join("");
			if (CONFIG.SHOW_SOURCE_NOTE) {
				const srcNote = document.createElement("p");
				srcNote.className = "lede";
				srcNote.textContent = `Source: ${source}`;
				container.prepend(srcNote);
			}
		}

		(async () => {
			try {
				const projects = await client.listProjects();
				render(projects, client.state.source);
			} catch (e) {
				container.innerHTML = `<p class="lede">Could not load projects (${e?.message || e}).</p>`;
			}
		})();

		/* =========================
		 * @section Test / Mock exports
		 * ========================= */
		window.__rops = Object.freeze({
			CONFIG,
			ProjectsDataClient,
			parseCSV,
			toMs,
			reset: () => client.reset(),
			destroy: () => client.destroy()
		});
	</script>
</body>

</html>
